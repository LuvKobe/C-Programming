### 1. 下面哪个是位操作符？

A. `&`

B. `&&`

C. `||`

D. `!`

**🌟解析：**

```c
答案解析：

A. & 是按位与操作符，正确

B. && 是逻辑与，不是按位与，错误

C. || 是逻辑或，错误

D. ! 是逻辑反操作符，错误
```



### 2. 下面代码的结果是？

```c
#include <stdio.h>

int main()
{
	int a, b, c;
	a = 5;
	c = ++a;
	b = ++c, c++, ++a, a++;
	b += a++ + c;
	printf("a = %d b = %d c = %d\n:", a, b, c);
	return 0;
}

A.a = 8 b = 23 c = 8
B.a = 9 b= 23 c = 8
C.a = 9 b = 25 c = 8
D.a = 9 b = 24 c = 8
```

**🌟解析：**

```c
答案解析：

++运算符：分为前置++和后置++，

前置++：先加1，后使用，即先使用变量中内容，然后给结果加1

后置++：先使用变量中内容，整个表达式结束时，给变量加1

逗号表达式，取最后一个表达式的值。
    
#include <stdio.h>
int main()
{
	int a, b, c;
	a = 5;
	c = ++a;// ++a：加给a+1，结果为6，用加完之后的结果给c赋值，因此：a = 6  c = 6
	b = ++c, c++, ++a, a++;
   // 逗号表达式的优先级，最低，这里先算b=++c, b得到的是++c后的结果，b是7
   // b=++c 和后边的构成逗号表达式，依次从左向右计算的。
   // 表达式结束时，c++和，++a,a++会给a+2，给c加1，此时c：8，a：8，b:7
	b += a++ + c; // a先和c加，结果为16，在加上b的值7，比的结果为23，最后给a加1，a的值为9
	printf("a = %d b = %d c = %d\n:", a, b, c); // a:9, b:23, c:8
	return 0;
}

因此：选择B
```



### 3. 求两个数二进制中不同位的个数

>编程实现：两个int（32位）整数m和n的二进制表达中，有多少个位(bit)不同？ 
>
>输入例子：1999 2299
>
>输出例子：7
>
>[两个整数二进制位不同个数](https://www.nowcoder.com/questionTerminal/9c3b8a8d9f1c4ae3b709d04625586225)

**📝代码实现：**

```c
/*
思路：
1. 先将m和n进行按位异或，此时m和n相同的二进制比特位清零，不同的二进制比特位为1
2. 统计异或完成后结果的二进制比特位中有多少个1即可
*/

#include <stdio.h>

int calc_diff_bit(int m, int n)
{
	int tmp = m ^ n;
	int count = 0;
	while (tmp)
	{
		tmp = tmp & (tmp - 1);
		count++;
	}
	return count;
}


int main()
{
	int m, n;
	while (scanf("%d %d", &m, &n) == 2)
	{
		printf("%d\n", calc_diff_bit(m, n));
	}
	return 0;
}
```



### 4. 打印整数二进制的奇数位和偶数位

>获取一个整数二进制序列中所有的偶数位和奇数位，分别打印出二进制序列

**📝代码实现：**

```c
/*
思路：
1. 提取所有的奇数位，如果该位是1，输出1，是0则输出0
2. 以同样的方式提取偶数位置


 检测num中某一位是0还是1的方式：
   1. 将num向右移动i位
   2. 将移完位之后的结果与1按位与，如果：
	  结果是0，则第i个比特位是0
	  结果是非0，则第i个比特位是1
*/
void Printbit(int num)
{
	for (int i = 31; i >= 1; i -= 2)
	{
		printf("%d ", (num >> i) & 1);
	}
	printf("\n");

	for (int i = 30; i >= 0; i -= 2)
	{
		printf("%d ", (num >> i) & 1);
	}
	printf("\n");
}
```



### 5. 统计二进制中1的个数

>写一个函数返回参数二进制中 1 的个数。
>
>比如： 15
>
>二进制表示：0000 1111  
>
>就是 4 个 1
>
>[二进制中1的个数](https://www.nowcoder.com/questionTerminal/8ee967e43c2c4ec193b040ea7fbb10b8)

**📝代码实现：**

```c
/*
方法一：
思路：
循环进行以下操作，直到n被缩减为0：
   1. 用该数据模2，检测其是否能够被2整除
   2. 可以：则该数据对应二进制比特位的最低位一定是0，否则是1，如果是1给计数加1
   3. 如果n不等于0时，继续1
*/
int count_one_bit(int n)
{
	int count = 0;
	while(n)
	{
		if(n%2==1)
			count++;
		n = n/2;
	}
	return count;
}
 
 
/*
上述方法缺陷：进行了大量的取模以及除法运算，取模和除法运算的效率本来就比较低。
方法二思路：
一个int类型的数据，对应的二进制一共有32个比特位，可以采用位运算的方式一位一位的检测，具体如下
*/
int count_one_bit(unsigned int n)
{
	int count = 0;
	int i = 0;
	for(i=0; i<32; i++)
	{
		if(((n>>i)&1) == 1)
			count++;
	}
	return count;
}
 
 
/*
方法二优点：用位操作代替取模和除法运算，效率稍微比较高
  缺陷：不论是什么数据，循环都要执行32次
  
方法三：
思路：采用相邻的两个数据进行按位与运算
举例：
9999：‭10 0111 0000 1111‬
第一次循环：n=9999   n=n&(n-1)=9999&9998= 9998
第二次循环：n=9998   n=n&(n-1)=9998&9997= 9996
第三次循环：n=9996   n=n&(n-1)=9996&9995= 9992
第四次循环：n=9992   n=n&(n-1)=9992&9991= 9984
第五次循环：n=9984   n=n&(n-1)=9984&9983= 9728
第六次循环：n=9728   n=n&(n-1)=9728&9727= 9216
第七次循环：n=9216   n=n&(n-1)=9216&9215= 8192
第八次循环：n=8192   n=n&(n-1)=8192&8191= 0
 
 
可以观察下：此种方式，数据的二进制比特位中有几个1，循环就循环几次，而且中间采用了位运算，处理起来比较高效
*/
int count_one_bit(int n)
{
	int count = 0;
	while(n)
	{
		n = n&(n-1);
		count++;
	}
	return count;
}
```



### 6. 交换两个变量（不创建临时变量）

>不允许创建临时变量，交换两个整数的内容

**📝代码实现：**

```c
// 方法一
#include <stdio.h>

int main()
{
	int a = 3;
	int b = 5;
	int c = 0;
	printf("交换前：");
	printf("a=%d b=%d\n", a, b);

	a = a + b;
	b = a - b;
	a = a - b;
	printf("交换后：");
	printf("a=%d b=%d\n", a, b);
	return 0;
}

//方法二
#include <stdio.h>

int main()
{
	int a = 10;
	int b = 20;
	printf("交换前:a = %d b = %d\n", a, b);
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("交换后:a = %d b = %d\n", a, b);
	return 0;
}
```









