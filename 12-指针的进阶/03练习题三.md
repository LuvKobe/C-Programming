### 1. 关于回调函数描述错误的是

**🔍 选项**

```markdown
A. 回调函数就是一个通过函数指针调用的函数

B. 回调函数一般通过函数指针实现

C. 回调函数一般不是函数的实现方调用，而是在特定的场景下，由另外一方调用。

D. 回调函数是调用函数指针指向函数的函数。
```

**✨ 解析**

```
“调用指针”、“指向函数”是什么鬼……

D选项简直逻辑鬼才！

ABC就是基础概念，可以复习下。
```



### 2. 下面 test 函数设计正确的是

**🔍 选项**

```c
char* arr[5] = {"hello", "bit"};

test(arr);
```

**🔍 选项**

```
A.void test(char* arr);
B.void test(char** arr);
C.void test(char arr[5]);
D.void test(char* arr[5]);
```

**✨ 解析**

```
指针的数组传递给子函数变为指针的指针，也就是二级指针。

但是允许中括号写法，写成char **arr、char *arr[]、char * arr[5]都可。

所以BD正确。
```



### 3. 下面程序的结果是

**📃 代码**

```c
int main()
{
  int aa[2][5] = {10,9,8,7,6,5,4,3,2,1};
  int *ptr1 = (int *)(&aa + 1);
  int *ptr2 = (int *)(*(aa + 1));
  printf( "%d,%d", *(ptr1 - 1), *(ptr2 - 1));
  return 0;
}
```

**🔍 选项**

```
A.1, 6
B.10, 5
C.10, 1
D.1, 5
```

**✨ 解析**

```
跟上题类似：&aa的类型是int (*)[2][5]，加一操作会导致跳转一个int[2][5]的长度，直接跑到刚好越界的位置。

减 1 以后回到最后一个位置 1 处。

*(aa + 1)相当于aa[1]，也就是第二行的首地址，自然是 5 的位置。

减 1 以后由于多维数组空间的连续性，会回到上一行末尾的 6 处。

故选A。
```



### 4. 下面代码中 print_arr 函数参数设计哪个是正确的

**📃 代码**

```c
int arr[3][5] = {1,2,3,4,5,6,7,8,9,10};
print_arr(arr, 3, 5);
```

**🔍 选项**

```
A.void print_arr(int arr[][],int row, int col);
B.void print_arr(int* arr, int row, int col);
C.void print_arr(int (*arr)[5], int row, int col);
D.void print_arr(int (*arr)[3], int row, int col);
```

**✨ 解析**

```
二维数组相当于数组的数组，传到子函数变成数组的指针。

int arr[3][5]相当于是3个元素的arr，每个元素是int[5]，所以int[5]是类型说明不能省略。

丢失的信息只有数组的元素个数，也就是3。

A丢了类型中的5，

B选项指针层级都错了，

D选项 5 写成了3，

故选C。
```



### 5. 下面程序的结果是

**📃 代码**

```c
int main()
{
  int a[5] = {5, 4, 3, 2, 1};
  int *ptr = (int *)(&a + 1);
  printf( "%d,%d", *(a + 1), *(ptr - 1));
  return 0;
}
```

**🔍 选项**

```
A.5, 1
B.4, 1
C.4, 2
D.5, 2
```

**✨ 解析**

```
*(a + 1)等同于a[1]，第一个是4，

a的类型是int [5]，&a的类型就是int(*)[5]，是个数组指针。

所以给int(*)[5]类型加一，相当于加了一个int [5]的长度。

也就是这个指针直接跳过了a全部的元素，直接指在了刚好越界的位置上，然后转换成了int *后再减一，相当于从那个位置向前走了一个int，从刚好越觉得位置回到了1的地址处，所以第二个是1，

故选B。
```



### 6. qsort 模拟实现

**题目内容**

>模仿 **qsort** 的功能实现一个通用的冒泡排序



### 7. qsort 使用练习

>练习使用库函数，**qsort** 排序各种类型的数据



