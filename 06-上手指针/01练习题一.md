### 1. 关于指针的概念，错误的是

**🔍 选项**

```
A.指针是变量，用来存放地址

B.指针变量中存的有效地址可以唯一指向内存中的一块区域

C.野指针也可以正常使用

D.局部指针变量不初始化就是野指针
```

**✨ 解析**

```
答案解析：

A：正确，指针变量中存储的是一个地址，指向同类型的一块内存空间

B：正确，地址是唯一的，一个指针变量中只能存储一个地址，因此可以唯一指向内存中的一块区域

C：野指针指向的空间时非法的，或者说该指针指向的空间已经不存在了，因此野指针不能使用

D：局部指针变量没有初始化时里面就是随机值，因此指向那个位置不一定，故将其看成是野指针

因此：选择C
```



### 2. 以下系统中，`int` 类型占几个字节，指针占几个字节，操作系统可以使用的最大内存空间是多大

**🔍 选项**

```
A.32位下：4,4,2^32 64位下：8,8,2^64
B.32位下：4,4,不限制 64位下：4,8,不限制
C.32位下：4,4,2^32 64位下：4,8,2^64
D.32位下：4,4,2^32 64位下：4,4,2^64
```

**✨ 解析**

```
答案解析：

32位系统下：

int占4个字节，指针表示地址空间个数，总共有2^32个，故占4个字节

64位系统下：

int占4个字节，指针表示地址空间个数，总共有2^64个，故占8个字节

因此：选择C
```



### 3. 下面代码的结果是

**📃 代码**

```c
#include <stdio.h>

int main()
{
  int arr[] = {1,2,3,4,5};
  short *p = (short*)arr;
  int i = 0;
  for(i=0; i<4; i++)
  {
    *(p+i) = 0;
  }
   
  for(i=0; i<5; i++)
  {
    printf("%d ", arr[i]);
  }
  return 0;
}
```

**🔍 选项**

```
A. 1 2 3 4 5
B. 0 0 3 4 5
C. 0 0 0 0 5
D. 1 0 0 0 0
```

**✨ 解析**

```
arr数组在内存中的存储格式为：

0x00ECFBF4:  01 00 00 00
0x00ECFBF8:  02 00 00 00
0x00ECFBFC:  03 00 00 00
0x00ECFC00:  04 00 00 00
0x00ECFC04:  05 00 00 00

指针p的类型为short*类型的，因此p每次只能所有两个字节，for循环对数组中内容进行修改时，一次访问的是：

arr[0]的低两个字节，arr[0]的高两个字节，arr[1]的低两个字节，arr[1]的高两个字节，故改变之后，数组中内容如下：

0x00ECFBF4:  00 00 00 00
0x00ECFBF8:  00 00 00 00
0x00ECFBFC:  03 00 00 00
0x00ECFC00:  04 00 00 00
0x00ECFC04:  05 00 00 00

故最后打印：0   0   3   4   5
```



### 4. 下列程序段的输出结果为

**📃 代码**

```c
unsigned long pulArray[] = {6,7,8,9,10};
unsigned long *pulPtr;
pulPtr = pulArray;
*(pulPtr + 3) += 3;
printf(“%d,%d\n”,*pulPtr, *(pulPtr + 3));
```

**🔍 选项**

```
A.9,12
B.6,9
C.6,12
D.6,10
```

**✨ 解析**

```
unsigned long pulArray[] = {6,7,8,9,10};
unsigned long *pulPtr;
pulPtr = pulArray; // 数组名代表数组首元素地址，因此pulptr指向的是数组中第一个元素的位置
*(pulPtr + 3) += 3; // pulptr+3访问的是数组中第三个元素(数组下标从0开始)，故将9改为9+3=12
printf(“%d,%d\n”,*pulPtr, *(pulPtr + 3)); // 打印第一个和第三个元素，因此：打印6和12
```



### 5. 关于二级指针描述描述正确的是

**🔍 选项**

```
A.二级指针也是指针，只不过比一级指针更大

B.二级指针也是指针，是用来保存一级指针的地址

C.二级指针是用来存放数组的地址

D.二级指针的大小是4个字节
```

**✨ 解析**

```
答案解析：

A：错误，二级指针是指针，不能说起比一级指针大，只能说二级指针指向的空间中存储的也是一个地址

B：正确

C：错误，数组的地址一般用一级指针存储，或者用数组指针接收

D：二级指针是指针，但是否占4个字节不一定，要看具体的系统

因此：选择B
```



### 6. 下面关于指针运算说法正确的是

**🔍 选项**

```
A. 整形指针+1，向后偏移一个字节

B. 指针-指针得到是指针和指针之间的字节个数

C. 整形指针解引用操作访问4个字节

D. 指针不能比较大小
```

**✨ 解析**

```
答案解析：

注意：此题是有问题的，说法不严谨，如果将整形指针理解成int*类型的指针，那么一下说法解析如下

A：错误，整形指针+1，向后便宜一个整形类型的大小，即4个字节

B：错误，两个指针相减，指针必须指向一段连续空间，减完之后的结构代表两个指针之间相差元素的个数

C：正确，整形指向的是一个整形的空间，解引用操作访问4个字节

D：指针中存储的是地址，地址可以看成一个数据，因此是可以比较大小的

因此：选择C
```



### 7. 下面代码输出的结果是

**📃 代码**

```c
#include <stdio.h>

int main()
{
	int a = 0x11223344;
    char *pc = (char*)&a;
    *pc = 0;
    printf("%x\n", a);
    return 0;
}
```

**🔍 选项**

```
A.00223344
B.0
C.11223300
D.112233
```

**✨ 解析**

```
答案解析：
 
假设，a变量的地址为0x64，则a变量在内存中的模型为：

0x64| 44 |
0x65| 33 |
0x66| 22 |
0x67| 11 |
 
char*类型的指针变量pc指向只能指向字符类型的空间，如果是非char类型的空间，必须要将该空间的地址强转为char*类型。
char *pc = (char*)&a; 
pc实际指向的是整形变量a的空间，即pc的内容为0x64，即44，
*pc=0，即将44位置中内容改为0，修改完成之后，a中内容为：0x11223300
 
因此：选择C
```



### 8. 下面哪个是指针数组

**🔍 选项**

```c
A.int* arr[10];
B.int * arr[];
C.int **arr;
D.int (*arr)[10];
```

**✨ 解析**

```
指针数组是一个数组，该数组的每个元素是一个指针

A：正确，定义了一个数组，该数组中有10个元素，每个元素都是int*的指针类型

B：错误，编译失败，定义数组时，要给出空间的大小，如果没有给时，必须要给出初始化结果

C：错误，定义了一个二级指针

D：错误，*和arr先结合，说明arr不是数组。实际上arr是一个指针，一个指向数组的指针。

因此：选择A
```



### 9. 使用指针打印数组内容

>写一个函数打印arr数组的内容，不使用数组下标，使用指针。
>
>arr 是一个整形一维数组。

**📝 代码实现：**

```c
#include <stdio.h>

void print_arr(int* arr, int sz)
{
	int i = 0;
	for (i = 0; i < sz; i++) {
		printf("%d ", *(arr + i));
        //printf("%d ", *arr++));
	}
}

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	// arr --> 表示的是首元素的地址
	// 用 int* 的指针接受
	print_arr(arr, sz);
	return 0;
}
```



### 10. 字符串逆序

>写一个函数，可以逆序一个字符串的内容。
>
>[字符逆序](https://www.nowcoder.com/questionTerminal/cc57022cb4194697ac30bcb566aeb47b)

**📝 代码实现：**

```c
#include <stdio.h>
#include <string.h>

int main()
{
	char str[10000] = { 0 };

	//输入
	gets(str);

	int len = strlen(str);
	char* left = str;
	char* right = str + len - 1;
	
    //逆序
	while (left < right) {
		char tmp = *left;
		*left = *right;
		*right = tmp;
		left++;
		right--;
	}
	printf("%s\n", str);
	return 0;
}
```



### 11. 计算求和

>求 $Sn=a+aa+aaa+aaaa+aaaaa$  的前5项之和，其中a是一个数字，
>
>例如：2+22+222+2222+22222

**📝 代码实现：**

```c
#include <stdio.h>

int main()
{
	int a = 0;
	int n = 0;
	scanf("%d %d", &n, &a);
	int sum = 0;
	int ret = 0;
	
	int i = 0;
	for (i = 0; i < n; i++) {
		ret = ret * 10 + a;
		sum += ret;
	}
	printf("%d\n", sum);
	return 0;
}
```



### 12. 打印水仙花数

>求出 $0～100000$ 之间的所有“水仙花数”并输出。
>
>“水仙花数”是指一个n位数，其各位数字的n次方之和确好等于该数本身
>
>水仙花数只是[自幂数](https://baike.baidu.com/item/自幂数)的一种，严格来说 **n** 位数的 **n** 次幂数才称为水仙花数。
>
>如：$153＝1^3 + 5^3 + 3^3$，则153是一个“水仙花数”。

**📝 代码实现：**

```c
/*
思路：
此题的关键在于只要知道判断一个数据是否为水仙花数的方式，问题就迎刃而解。假定给定一个数据data，具体检测方式如下：
1. 求取data是几位数
2. 获取data中每个位置上的数据，并对其进行立方求和
3. 对data中每个位上的数据立方求和完成后，在检测其结果是否与data相等即可，
相等：则为水仙花数
否则：不是
具体实现参考以下代码。
*/

#include <stdio.h>
#include <math.h>
int main()
{
	int i = 0;
	for (i = 0; i < 100000; i++) {
		int n = 1;
		int sum = 0;
		int tmp = i;

		//i是n位数
		while (tmp /= 10) {
			n++;
		}

		// 求每一位的n次方之和
		tmp = i;
		while (tmp) {
			sum += (int)pow(tmp % 10, n);
			tmp /= 10;
		}
		if (sum == i) {
			printf("%d ", i);
		}
	}
	return 0;
}
```



### 13. 打印菱形

>用 **C** 语言在屏幕上输出以下图案：
>
>![image-20220619213913405](C:\Users\30786\AppData\Roaming\Typora\typora-user-images\image-20220619213913405.png)

**🌟 解题思路：**

>假设要打印的是下面这个菱形，仔细观察图形，可以发现，此图形中是由 **空格** 和 `*` 按照不同个数的输出组成的。
>
>![image-20220619220532269](https://gitee.com/LuvKobe/cloudimg/raw/master/img/202206192205314.png)
>
>![image-20220619220049649](C:\Users\30786\AppData\Roaming\Typora\typora-user-images\image-20220619220049649.png)
>
>因此我们可以把图形分为两个部分来打印，分别是：**上三角** 和 **下三角**；
>
>**上三角（前 5 行）：** 
>
>先输出 **空格**，后输出 `*`。
>
>比如，第一行我们应该先打印 **4** 个空格再打印 **1** 个星号
>
>可以发现，每一行都在重复两个动作，打印空格和打印星号，所以我们很容易想到用循环。
>
>**i** 表示第几行，**j** 表示空格数，**k** 表示 `*`
>
>**我们列出上三角的所有部分：**
>
>|    i    |    j     |    k     |
>| :-----: | :------: | :------: |
>| 第 1 行 | 4 个空格 | 1 个 `*` |
>| 第 2 行 | 3 个空格 | 3 个 `*` |
>| 第 3 行 | 2 个空格 | 5 个 `*` |
>| 第 4 行 | 1 个空格 | 7 个 `*` |
>| 第 5 行 | 0 个空格 | 9 个 `*` |
>
>空格与行数的关系：`j = line - i - 1`，从上往下，一行减少一个。（ line 表示上三角有多少行）
>
>`*` 与 行数的关系：`k = 2 * i + 1` 的方式递增
>
>**下三角（后 4 行）：**
>
>先输出 **空格**，后输出 `*`。
>
>**我们列出下三角的所有部分：**
>
>|    i    |    j     |    k     |
>| :-----: | :------: | :------: |
>| 第 1 行 | 1 个空格 | 7 个 `*` |
>| 第 2 行 | 2 个空格 | 5 个 `*` |
>| 第 3 行 | 3 个空格 | 3 个 `*` |
>| 第 4 行 | 4 个空格 | 1 个 `*` |
>
>空格与行数的关系：`j = i`，从上往下，每行多一个空格；
>
>`*` 与 行数的关系：`k = 2 * (line - 1 - i) - 1` 的方式递增（ line - 1 表示下三角有多少行）
>
>按照上述方式，将上三角和下三角中的 **空格** 和 `*` 分别输出即可。

**📝 代码实现：**

```c
#include <stdio.h>

void Print_rhombus(int line) {
	//上三角 --> 前 line 行
	int i = 0;
	for (i = 0; i < line; ++i) {
		//打印空格
		int j = 0;
		for (j = 0; j < line - i - 1; ++j) {
			printf(" ");
		}

		//打印 *
		int k = 0;
		for (k = 0; k < 2 * i + 1; ++k) {
			printf("*");
		}
		printf("\n");
	}

	//下三角 --> 后 line-1 行
	for (i = 0; i < line - 1; ++i) {
		//打印空格
		int j = 0;
		for (j = 0; j <= i; ++j) {
			printf(" ");
		}

		//打印 *
		int k = 0;
		for (k = 0; k < 2 * (line - 1 - i) - 1; ++k) {
			printf("*");
		}
		printf("\n");
	}

}

int main()
{
	int line = 0;
	scanf("%d", &line);
	Print_rhombus(line); //打印菱形函数
	return 0;
}
```

