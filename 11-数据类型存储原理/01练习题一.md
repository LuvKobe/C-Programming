### 1. 原码、反码、补码说法错误的是

**🔍 选项**

```
A.一个数的原码是这个数直接转换成二进制

B.反码是原码的二进制符号位不变，其他位按位取反

C.补码是反码的二进制加1

D.原码、反码、补码的最高位是0表示负数，最高位是1表示正数
```

**✨ 解析**

```
```



### 2. 程序的执行结果为

**📃 代码**

```c
int main()
{
  unsigned char a = 200;
  unsigned char b = 100;
  unsigned char c = 0;
  c = a + b;
  printf(“%d %d”, a+b,c);
  return 0;
}
```

**🔍 选项**

```
A.300 300
B.44 44
C.300 44
D.44 300
```

**✨ 解析**

```
```



### 3. 在32位大端模式处理器上变量b等于

**📃 代码**

```c
unsigned int a= 0x1234; unsigned char b=*(unsigned char *)&a;
```

**🔍 选项**

```c
A.0x00

B.0x12

C.0x34

D.0x1234
```

**✨ 解析**

```
```



### 4. 下面代码的结果是

**📃 代码**

```c
int main()
{
  char a[1000] = {0};
  int i=0;
  for(i=0; i<1000; i++)
  {
    a[i] = -1-i;
  }
  printf("%d",strlen(a));
  return 0;
}
```

**🔍 选项**

```
A.1000
B.999
C.255
D.256
```

**✨ 解析**

```

```





### 5. 关于大小端字节序的描述正确的是

**🔍 选项**

```
A.大小端字节序指的是数据在电脑上存储的二进制位顺序

B.大小端字节序指的是数据在电脑上存储的字节顺序

C.大端字节序是把数据的高字节内容存放到高地址，低字节内容存放在低地址处

D.小端字节序是把数据的高字节内容存放到低地址，低字节内容存放在高地址处
```

**✨ 解析**

```

```



### 6. 杨辉三角

>在屏幕上打印杨辉三角。

**📝 代码实现**

```c
#include <stdio.h>

int main()
{
	int i, j, n, k, t;
	long data[21] = { 0,1 };    //用于保存一行数据
	printf("请输入杨辉三角形的行数（1 - 20）：");
	scanf("%d", &n);
	for (i = 1; i <= n; i++)	//输出n行
	{
		for (j = 0; j < n - i; j++)	//每行前面补空格，形成等腰三角图案	
			printf("   ");
		t = 0;
		for (j = 1; j <= i; j++)//计算并输出杨辉三角形
		{
			k = data[j];
			data[j] = t + k;		//每个数是上面两数之和（三角计算）
			t = k;
			printf("%6d", data[j]);
		}
		printf("\n");
	}
	return 0;
}
```



### 7. 猜凶手

>日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。
>
>以下为4个嫌疑犯的供词:
>
>A说：不是我。
>
>B说：是C。
>
>C说：是D。
>
>D说：C在胡说
>
>已知3个人说了真话，1个人说的是假话。
>
>现在请根据这些信息，写一个程序来确定到底谁是凶手。

**🌟 解题思路**

程序猿逻辑，逐个分析：

>​            如果A说了假话，BCD三人就说的是真话：
>​                           则凶手是A，凶手是C，凶手是D，C在胡说。       凶手只有1个，排除；
>
>​            如果B说了假话，ACD三人就说的是真话：
>​                           则凶手不是A，凶手是C，凶手是D，C在胡说。     凶手只有1个，排除；
>
>​            如果C说了假话，ABD三人就说的是真话：
>​                           则凶手不是A，凶手是C，凶手不是D，C在胡说。条件可能成立。凶手可能是C
>
>​            如果D说了假话，ABC三人就说的是真话：
>​                           则凶手不是A，凶手是C，凶手是D，凶手是D。     凶手只有1个，排除；
>
>​            这样做下来，我们排除后只剩下一种可能，C说了假话，C是凶手

按照这样的逻辑，我们虽然可以分析出C是凶手，但代码却并不友好。我们可以换个思路：

>计算机逻辑：
>
>用三个人说真话，一个人说假话作为条件（0为假，1为真）；       
>
>一共只有四种情况，A/B/C/D为凶手       
>
>用凶手分别遍历ABCD，四者供词加在一起，只要等于3，就可以得到凶手了

**📝 代码实现**

```c
#include <stdio.h>

void Murder() {
	char k; // k代表凶手
	for (k = 'A'; k <= 'D'; ++k) {
		if (3 == (k != 'A') + (k == 'C') + (k == 'D') + (k != 'D')) {
			printf("%c是凶手\n", k);
		}
	}
}

int main()
{
	Murder(); //谋杀案函数
	return 0;
}
```



### 8. 猜名次

>5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果：
>
>A选手说：B第二，我第三；
>
>B选手说：我第二，E第四；
>
>C选手说：我第一，D第二；
>
>D选手说：C最后，我第三；
>
>E选手说：我第四，A第一；
>
>比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。

**🌟解题思路：**

>一共有5名运动员、5个名次。首先用一个5重循环确定5名运动员所有可能出现的名次，在用两个判断条件判断符合条件的输出就是最终的结果。
>
>两个判断条件：第一个是各个运动员的名次不可能一样。
>
>第二个是每位选手都说对了一半(既A运动员说的话(（b==2）+(a==3)==1) ）
>
>或者利用异或(不一样才为真，一样时为假)

**📝代码实现**

```c
int main()
{
	int a = 0;
	int b = 0;
	int c = 0;
	int d = 0;
	int e = 0;

	//利用for循环的嵌套
	for (a = 1; a <= 5; a++)
	{
		for (b = 1; b <= 5; b++)
		{
			for (c = 1; c <= 5; c++)
			{
				for (d = 1; d <= 5; d++)
				{
					for (e = 1; e <= 5; e++)
					{
						//每个人说的话，有一半是正确的，那么肯定是正确的为1，错误的为0
						if (((b == 2) + (a == 3) == 1) &&
							((b == 2) + (e == 4) == 1) &&
							((c == 1) + (d == 2) == 1) &&
							((c == 5) + (d == 3) == 1) &&
							((e == 4) + (a == 1) == 1)) {
							// 把名次相乘：1*2*3*4*5=120
							if (a * b * c * d * e == 120) {
								printf("a=%d b=%d c=%d d=%d e=%d\n", a, b, c, d, e);
							}
						}
					}
				}
			}
		}
	}
	return 0;
}
```



### 9. 小乐乐改数字

>题目链接：[小乐乐改数字](https://www.nowcoder.com/practice/fcd30aac9c4f4028b23919a0c649824d?tpId=107&&tqId=33397&rp=1&ru=/ta/beginner-programmers&qru=/ta/beginner-programmers/question-ranking)

**📝 代码实现**

```c
int main()
{
	int n = 0; //定义一个长整型
	scanf("%d", &n);

	int ret = 0; //从最低位开始，依次往高位累加
	int i = 0;
	int single = 0;
	while (n) {
		single = n % 10; //计算最低位

		// 判断奇偶性
		if ((single & 1) == 0) { 
			single = 0;
		}
		else {
			single = 1;
		}
		ret = ret + single * pow(10, i++);
		n /= 10;
	}
	printf("%d", ret);
	return 0;
}
```



### 10. 小乐乐走台阶

>题目链接：[小乐乐走台阶](https://www.nowcoder.com/practice/ebf04de0e02c486099d78b7c3aaec255?tpId=107&&tqId=33398&rp=1&ru=/ta/beginner-programmers&qru=/ta/beginner-programmers/question-ranking)

**🌟 解题思路：**

> 要用递归来解决这个问题
>
> 先不看整体，递归先用一个个例子来看就清楚了
>
> 假设有n级台阶：

```c
1级台阶：
   台阶走1步就到，结果为1。即f(1)=1
    
2级台阶：
   台阶走1步到，或台阶走2步到，即f(2)=2
    
3级台阶
   走到3级台阶前，乐乐肯定必须到达1级台阶或2级台阶：
   3级台阶最后一步为1，乐乐前一步到达2级台阶，到达2级台阶有f(2)种走法
   3级台阶最后一步为2，乐乐前一步到达1级台阶，到达1级台阶有f(1)种走法
   总的走法为f(1)+f(2)
    
n级台阶：
   到最后完成前,乐乐可以走2步也可以走1步，
   走1步：
   在这1步前的走法为f(n-1)
   走2步：
   在这2步前的走法为f(n-2)

总结:
   走完n级的台阶，
   f(n)=f(n-1)+f(n-2)
   可以理解成，
   走完n级台阶的走法 = 最后一步是1的走法 + 最后一步是2的走法
   走完n级台阶的走法 = 到达n-1级台阶的走法 + 到达n-2级台阶的走法

即：f(n)=f(n-1)+f(n-2)
       
实际上反应这种递归的经典例子就是斐波那契数列，也叫兔子数列，即某项为前两项之和
```

**📝 代码实现**

```c
#include <stdio.h>

int steps(int n) {
	int ret = 0;
	if (n == 1 || n == 2) {
		return n;
	}
	else {
		return steps(n - 1) + steps(n - 2);
	}
		
}

int main()
{
	int n = 0;
	printf("请输入台阶数:> ");
	scanf("%d", &n);
	int ret = steps(n);
	printf("一共有%d种走法\n", ret);
	return 0;
}
```



